/*
@name functions

@guide
Place SASS mixins and functions here.
*/




/*
@name mq

@description
Mixin for a basic media query from our $media-query
map.

@param {string} query
A key in our $media-query map that we are fetching.

@example
.hello{
    @include query("m"){
        color: red;
    }
}
*/

@mixin mq($query){

    @if(map_has_key($media-query, $query)){

        @media #{map-get($media-query, $query)}{
            @content;
        }

    } @else {
        
        @media #{$query}{
            @content;
        }

    }

}




/*
@name convertMQValue

@description
Function to convert a media query value from our 
$media-query-values to a min or max media query
by adding or subtracting 1 from the value.
This is useful to prevent media queries conflicting
when using min and max-width media queries.

@param {string} MQValue
A key in our $media-query-values map that we are fetching.

@param {boolean} toMax
Determines whether to convert to min or max.

@example
.hello{
    @media (max-width: convertMQValue("s")){
        color: blue;
    }
}
*/

@function convertMQValue($MQValue, $toMax: true){

    @if (map_has_key($media-query-values, $MQValue)){

        $query: "";
    
        @if($toMax == true){
            $query: map-get($media-query-values, $MQValue) - 1;
        } @else {
            $query: map-get($media-query-values, $MQValue) + 1;
        }

        @return $query;

    } @else{
        @error "Can't convert MQ value. Map key doesn't exist.";
    }

}





/*
@name aspect-ratio

@description
Mixin to preserve aspect ratios.

@param {number} width
@param {number} height

@example
@include aspect-ratio(16, 9);
*/

@mixin aspect-ratio($width, $height){
    position: relative;
    padding-top: ($height / $width) * 100%;
}





/*
@name overlay

@description
Mixin to create an overlay.
The overlay can be toggled with a class
(class--toggled) or by hover. If you're
toggling via hover, you'll need to wrap
the overlay. See the overlay-parent mixin below.

@param {boolean} hidden
Determines whether to hide the overlay
with display or with opacity and
visiblility so we can transition.

@example
.overlay{
    @include overlay(false, false);
}
*/

@mixin overlay($hidden: false, $fixed: true){
    
    @if ($hidden == true){
        display: none !important;
    } @else {
        opacity: 0;
        visibility: hidden;
        transition: opacity map-get($transition-speed, "fast") map-get($transition-type, "linear");
    }

    @if ($fixed == true){
        position: fixed;
        transform: translateZ(0);
        top:    0;
        left:   0;
        right:  0;
        bottom: 0;
    } @else {
        position: absolute;
        left:   map-get($overlay, "offset");
        right:  map-get($overlay, "offset");
        top:    map-get($overlay, "offset");
        bottom: map-get($overlay, "offset");
    }

    background-color: map-get($overlay, "background-color");
    overflow-x: hidden;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    z-index: map-get($z-index, "overlay");
    padding: map-get($overlay, "padding");

    &--toggled{

        @if ($hidden == true){
            display: block !important;
        } @else {
            opacity: 1;
            visibility: visible;
        }

    }
}





/*
@name overlay-parent

@description
Mixin to show an overlay. The overlay
must be a child of the element that this mixin
is applied to.

@param {boolean} hidden
Determines whether to show the overlay
with display or with opacity and
visiblility so we can transition.

@param {string} child
The class name of the overlay that we
are trying to show. This should be a child
of the element that you are applying this mixin to.

@example
.overlay__parent{
    @include overlay-parent(false, myOverlay);
}

.myOverlay{
    @include overlay(false, false);
}

This will reveal .myOverlay when we hover over .overlay__parent.
*/

@mixin overlay-parent($hidden: false, $child: overlay){
    position: relative;
    
    &:hover{
        
        & .#{$child}{
            @if ($hidden == true){
                display: block !important;
            } @else {
                opacity: 1;
                visibility: visible;
            }
        }
    }

}





/*
@name createGrid

@description
Mixin to create flexbox grids.

@param {number} cols - the number of columns in the grid.

@param {number} widthOffset
The offset of the column width.
The width of the columns will be subtracted by this amount.
We create an offset because we are using
flexbox with justify-content: space between.
This will automatically create a more intelligent gutter.

@param {string} className
The class name of the grid that will be outputted.
The child classname will have a suffix of "__item".

@example
With static number of columns.
@include createGrid(2, 3, "grid--2");
This will create a grid of 2 columns with
a width of 47% each ((100 / 2) - 3)

@example
With changing number of columns.
@include createGrid(2, 3, "grid--2-4"){

    @include query("m"){

        .grid--2-4__item{
            width: 22%;
        }
    }

}
*/

@mixin createGrid($cols, $widthOffset, $className){
    
    .#{$className}{
        display: flex;
        flex-wrap: wrap;
        flex-direction: row;
        justify-content: space-between;
    }

    .#{$className}__item{
        width: (100% / $cols) - $widthOffset;
        margin-bottom: $widthOffset + 0%;

        @for $i from $cols through 1{
            
            &:nth-last-of-type(#{$i}){
                margin-bottom: 0;
            }

        }

    }

    @content;

    @at-root{

        .no-flexbox{

            .#{$className}{
                display: block;
                overflow: hidden;
            }
            
            .#{$className}__item{
                padding-left:  $widthOffset;
                padding-right: $widthOffset;
            }
        }
    }

}





/*
@name createGridUnits

@description
Mixin to create grid units. Grid units are just classes with
a given width and a margin. The idea behind it is to have
pieces that you can place together to form a full width row
with a gutter included.

@param {number} gutter
the size of the gutter. Don't include
the unit, it will be outputted as a percentage.

@param {number} MQ
the min width media query
for the styles to take effect.

@example [SCSS]
@include createGridUnits(1.53846154, 750px);

@example [HTML]
<div class='grid-unit--7'>Nav</div>
<div class='grid-unit--2'>Logo</div>
<div class='grid-unit--7'>Cart</div>
*/

@mixin createGridUnits($gutter, $MQ){

    $base: 100 - ($gutter * 2);
    $count: round($base / ($gutter * 4));
    
    @media (min-width: #{$MQ}){
        
        [class*="grid-unit"]{
            margin-left: $gutter + 0%;
            float: left;

            &:last-child{
                margin-right: $gutter + 0%;
            }
        }
    
        @while $base > 0{
            
            .grid-unit--offset-#{$count}{
                margin-left: $base + 0%;

                &:last-child{
                    margin-right: $base + 0%;
                }
            }

            .grid-unit--#{$count}{
                width: $base + 0%;
            }
                
            $base: $base - ($gutter * 4);
            $count: $count - 1;

        }

        .grid-unit--offset-gutter{
            margin-left: ($gutter / 2) + $gutter + 0%;

            &:last-child{
                margin-right: ($gutter / 2) + $gutter + 0%;
            }
        }

    }

}





/*
@name map-deep-get

@author Hugo Giraudel

@param {map} $map - Map
@param {Arglist} $keys - Key chain

@description
map-deep-get is not compatible with createClassesFromMap().
https://css-tricks.com/snippets/sass/deep-getset-maps/#article-header-id-0
*/

@function map-deep-get($map, $keys){

    @each $key in $keys {
        $map: map-get($map, $key);
    }

    @return $map;
}





/*
@name createClassesFromMap

@description
This mixin takes a given map and iterates through the keys
and creates css classes based on the key-value pairs.
Additionally, all values are outputted with !important because they
are intended to be used as trumps. Removing !important may result
in styles getting overidden by BBUI. map-deep-get is not compatible with createClassesFromMap().

@param {string} property
the name of the property that will be outputted.

@param {map} map
the SASS map where we get the data from
and iterate through the key-value pairs.

@param {boolean} createMQs
Determines whether to wrap the styles in media queries along 
with the the regular styles. It gets the media queries
from our $media-query map.

@param {string} className
Optional. The classname that will be outputted, 
suffixed with "--" then the value of the property.
Ex: text-decoration--none
The suffix is for a BEM like structure.
If omitted, the class name will default to the param $property's value.

@example
@include createClassesFromMap(font-family, $font-family);
*/

@mixin createClassesFromMap($property, $map, $createMQs: false, $className: $property){

    @each $key, $value in $map{

        @if ($value != ""){
            
            .#{$className} {
            
                &--#{$key}{
                    #{$property}: $value !important;
                }

            }
            
            @if (type_of($createMQs) != bool){
                @error "$createMQs is not of boolean type.";
            } @elseif ($createMQs == true){

                @each $MQKey, $MQValue in $media-query{

                    @media #{$MQValue}{
                
                        .#{$className}--#{$key}-on-#{$MQKey}{
                            #{$property}: $value !important;
                        }

                    }

                }

            }
            
        } @else {
            @warn "Value missing when trying to createClassesFromMap().";
        }

    }
}




/*
@name createIncrementalNumberClasses

@description
Creates a series of classes like createClassesFromMap(),
except it appends an incrementing number on each next class.
See createClassesFromMap() for property and className parameters.

@param {number} increment - the amount to increment by each loop.
@param {number} max - the amount of times to loop. 

@example
@include createIncrementalNumberClasses(max-height, max-height, 50, 15);
Could produce something like:

.max-height--50{
    max-height: 50px;
}
.max-height--100{
    max-height: 100px;
}
*/

@mixin createIncrementalNumberClasses($property, $className, $increment, $max){

    @for $i from 1 through $max{

        $val: ($i * $increment);

        .#{$className}--#{$val}{
            #{$property}: #{$val}px !important;
        }

    }

}
