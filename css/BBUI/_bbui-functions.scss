/*
@name functions

@guide
Place SASS mixins and functions here.
*/




/*
@name mq

@description
Mixin for a basic media query from our $media-query
map.

@param {string} query
A key in our $media-query map that we are fetching.

@example
.hello{
    @include query("m"){
        color: red;
    }
}
*/

@mixin mq($query){

    @if(map_has_key($media-query, $query)){

        @media #{map-get($media-query, $query)}{
            @content;
        }

    } @else {
        
        @media #{$query}{
            @content;
        }

    }

}




/*
@name convertMQValue

@description
Function to convert a media query value from our 
$media-query-values to a min or max media query
by adding or subtracting 1 from the value.
This is useful to prevent media queries conflicting
when using min and max-width media queries.

@param {string} MQValue
A key in our $media-query-values map that we are fetching.

@param {boolean} toMax
Determines whether to convert to min or max.

@example
.hello{
    @media (max-width: convertMQValue("s")){
        color: blue;
    }
}
*/

@function convertMQValue($MQValue, $toMax: true){

    @if (map_has_key($media-query-values, $MQValue)){

        $query: "";
    
        @if($toMax == true){
            $query: map-get($media-query-values, $MQValue) - 1;
        } @else {
            $query: map-get($media-query-values, $MQValue) + 1;
        }

        @return $query;

    } @else{
        @error "Can't convert MQ value. Map key doesn't exist.";
    }

}





/*
@name aspect-ratio

@description
Mixin to preserve aspect ratios.

@param {number} width
@param {number} height

@example
@include aspect-ratio(16, 9);
*/

@mixin aspect-ratio($width, $height){
    position: relative;
    padding-top: ($height / $width) * 100%;
}





/*
@name overlay

@description
Mixin to create an overlay.
The overlay can be toggled with a class
(class--toggled) or by hover. If you're
toggling via hover, you'll need to wrap
the overlay. See the overlay-parent mixin below.

@param {boolean} hidden
Determines whether to hide the overlay
with display or with opacity and
visiblility so we can transition.

@example
.overlay{
    @include overlay(false, false);
}
*/

@mixin overlay($fixed: true){
    $overlaySelector: &;

    opacity: 0;
    visibility: hidden;
    transition: opacity map-get($transition-speed, "fast") map-get($transition-type, "ease");
    top:    0;
    left:   0;
    right:  0;
    bottom: 0;

    @if ($fixed == true){
        position: fixed;
        transform: translateZ(0);
    } @else {
        position: absolute;
    }

    background-color: map-get($overlay, "background-color");
    overflow-x: hidden;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    z-index: map-get($z-index, "overlay");
    padding: map-get($overlay, "padding");
    
    // Fixed doesn't play well on touch.
    @include ifTouch{
        position: absolute;
    }

    &--toggled{
        @extend .lock-scroll;

        #{$overlaySelector}{
            opacity: 1;
            visibility: visible;
        }

    }
}







/*
@name overlay-parent

@description
Mixin to show an overlay. The overlay
must be a child of the element that this mixin
is applied to.

@param {boolean} hidden
Determines whether to show the overlay
with display or with opacity and
visiblility so we can transition.

@param {string} child
The class name of the overlay that we
are trying to show. This should be a child
of the element that you are applying this mixin to.

@example
.overlay__parent{
    @include overlay-parent(false, myOverlay);
}

.myOverlay{
    @include overlay(false, false);
}

This will reveal .myOverlay when we hover over .overlay__parent.
*/

@mixin overlay-parent($child: overlay){
    position: relative;
    display: block;
    
    &:hover{
        
        & .#{$child}{
            opacity: 1;
            visibility: visible;
        }
    }

}





/*
@name createGrid

@description
Mixin to create flexbox grids.

@param {number} cols - the number of columns in the grid.

@param {number} widthOffset
The offset of the column width.
The width of the columns will be subtracted by this amount.
We create an offset because we are using
flexbox with justify-content: space between.
This will automatically create a more intelligent gutter.

@param {string} className
The class name of the grid that will be outputted.
The child classname will have a suffix of "__item".

@example
With static number of columns.
@include createGrid(2, 3, "grid--2");
This will create a grid of 2 columns with
a width of 47% each ((100 / 2) - 3)

@example
With changing number of columns.
@include createGrid(2, 3, "grid--2-4"){

    @include query("m"){

        .grid--2-4__item{
            width: 22%;
        }
    }

}
*/

@mixin createGrid($cols, $widthOffset, $className){

    .#{$className}__item{

        @if($cols == 1){
            width: 100%;
        } @else {
            width: (100% / $cols) - $widthOffset;
        }
        
        @if($cols > 1){
            margin-bottom: (100 - ((100% / $cols - $widthOffset) * $cols)) / ($cols - 1);
        } @else {
            margin-bottom: (100 - ((100% / $cols - $widthOffset) * $cols));
        }

        @for $i from $cols through 1{
            
            &:nth-last-of-type(#{$i}){
                margin-bottom: 0;
            }

        }

    }

    @content;

    @at-root{

        .no-flexbox{
            
            .#{$className}__item{
                padding-left:  1%;
                padding-right: 1%;
                float: left;
            }
        }
    }

}





/*
@name createGridUnits

@description
Mixin to create grid units. Grid units are just classes with
a given width and a margin. The idea behind it is to have
pieces that you can place together to form a full width row
with a gutter included.

@param {number} gutter
the size of the gutter. Don't include
the unit, it will be outputted as a percentage.

@param {number} MQ
the min width media query
for the styles to take effect.

@example [SCSS]
@include createGridUnits(1.53846154, 750px);

@example [HTML]
<div class='grid-unit--7'>Nav</div>
<div class='grid-unit--2'>Logo</div>
<div class='grid-unit--7'>Cart</div>
*/

@mixin createGridUnits($gutter, $MQ){

    $base: 100 - ($gutter * 2);
    $count: $base / ($gutter * 2);
    
    @media (min-width: #{$MQ}){
        
        [class*="grid-unit"]{
            margin-left: $gutter + 0%;
            float: left;
        }
    
        @while $base > 0{
            
            .grid-unit--offset-#{round($count)}{
                margin-left: $base + 0%;
            }

            .grid-unit--#{round($count)}{
                width: $base + 0%;
            }
                
            $base: $base - ($gutter * 2);
            $count: $base / ($gutter * 2);

        }

        .grid-unit--offset-gutter{
            margin-left: $gutter + 0%;
        }

    }

}





/*
@name map-deep-get

@author Hugo Giraudel

@param {map} $map - Map
@param {Arglist} $keys - Key chain

@description
map-deep-get is not compatible with createClassesFromMap().
https://css-tricks.com/snippets/sass/deep-getset-maps/#article-header-id-0
*/

@function map-deep-get($map, $keys){

    @each $key in $keys {
        $map: map-get($map, $key);
    }

    @return $map;
}





/*
@name createClassesFromMap

@description
This mixin takes a given map and iterates through the keys
and creates css classes based on the key-value pairs.
Additionally, all values are outputted with !important because they
are intended to be used as trumps. Removing !important may result
in styles getting overidden by BBUI. map-deep-get is not compatible with createClassesFromMap().

@param {string} property
the name of the property that will be outputted.

@param {map} map
the SASS map where we get the data from
and iterate through the key-value pairs.

@param {boolean} createMQs
Determines whether to wrap the styles in media queries along 
with the the regular styles. It gets the media queries
from our $media-query map.

@param {string} className
Optional. The classname that will be outputted, 
suffixed with "--" then the value of the property.
Ex: text-decoration--none
The suffix is for a BEM like structure.
If omitted, the class name will default to the param $property's value.

@example
@include createClassesFromMap(font-family, $font-family, false, ff);
*/

@mixin createClassesFromMap($property, $map, $createMQs: false, $className: $property){

    @each $key, $value in $map{

        @if ($value != ""){
            
            .#{$className} {
            
                &--#{$key}{
                    #{$property}: $value !important;
                }

            }
            
        } @else {
            @warn "Value missing when trying to createClassesFromMap().";
        }

    }

    @each $key, $value in $map{
        
        @if (type_of($createMQs) != bool){
            @error "$createMQs is not of boolean type.";
        } @elseif ($createMQs == true){

            @each $MQKey, $MQValue in $media-query{

                @media #{$MQValue}{
            
                    .#{$className}--#{$key}-on-#{$MQKey}{
                        #{$property}: $value !important;
                    }

                }

            }

        }

    }
}





/*
@name noFlex

@description
Mixin for checking if the browser supports flex.

@example
.hello{
    @include noFlex{
        display: block;
    }
}
*/

@mixin noFlex{

    $selector: &;
    
    @at-root{

        .no-flexbox{
            
            #{$selector}{
                @content;
            }
        }
    }
}





/*
@name ifTouch

@description
Mixin for checking if the browser has touchevents,
excluding desktop.

@example
.hello{
    @include ifTouch{
        opacity: 1;
    }
}
*/

@mixin ifTouch{

    $selector: &;
    
    @at-root{

        .touchevents:not(.desktop){
            
            #{$selector}{
                @content;
            }
        }
    }
}





/*
@name displayOn

@description
Mixin to produce classes that are hidden
with display: none, and then shown at
a given media query from our $media-query map.
*/

@mixin displayOn{

    [class*="display-on--"]{
        display: none !important;
    }
    
    @each $key, $value in $media-query{
        
        @media #{$value}{
            
            .display-on--#{$key}{
                display: block !important;
            }
        }
    }
}
